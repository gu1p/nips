# NIP-404: Ghost Events

`draft` `optional`

This NIP introduces **Ghost Events**‚Äîa protocol for creating events that are **plausibly deniable** with a **ephemeral**
nature, providing a weak binding to the author's identity. It leverages ring signatures, elliptic curve point-hashing, and a distance-based proof-of-work that references Bitcoin block hashes for chronological anchoring.

---

## 1. Motivation & Overview

**Plausible Deniability**  
   Nostr events are permanently linked to the signing public key. Ghost Events only *weakly* link to a user‚Äôs main key, so the user can later deny authorship.

**Ephemerality**  
   Each Ghost Event references a Bitcoin block, providing a **time anchor**. As time passes, more ‚Äúmined keys‚Äù satisfying the same proof-of-work can appear, so the event‚Äôs authorship becomes questionable.  

**Based on public information**  
   All components of a Ghost Event are public, so anyone can forge one referencing your key. This ensures that no one can definitively prove you authored it.


**Maintain Main Identity**  
   You keep your main key for official posts, but can also create Ghost Events that won‚Äôt tarnish your identity if they become embarrassing or sensitive later.

### High-Level Mechanics

- **Ring Signature** over exactly two keys:  
  1) Your real key;  
  2) A ‚Äúmined‚Äù key‚Äîfound by solving a proof-of-work puzzle.  
- **Distance-based PoW**: The mined key‚Äôs public key must be within distance $\delta$ of a ‚Äúchallenge point‚Äù derived from your public key and a Bitcoin block hash.  
- **Deniability**: Verifiers can only tell that *one* of the two keys signed the event, not which one. Because all components are public, anyone can forge a Ghost Event referencing your key.

---

## 2. Detailed Protocol

### 2.1. Reference a Bitcoin Block

Pick a Bitcoin block $B$ with hash $H_B$ and timestamp $t_B$. This block anchors the event in time.

### 2.2. Derive a Challenge Point

1. Take your main public key $P_A$ and concatenate it with $H_B$.  
2. Compute $S = \mathrm{SHA256}(P_A \,\|\, H_B)$.  
3. Map $S$ to secp256k1 ([RFC 9380 ‚ÄúHashing to Elliptic Curves‚Äù](https://www.rfc-editor.org/rfc/rfc9380)):  $\mathrm{challenge_PK} = \mathrm{HashToCurve}(S).$

Anyone can verify this point by performing the same steps.

### 2.3. Pick a ‚ÄúMined Key‚Äù $P_{\mathrm{mined}}$

- Let $x_c$ be the $x$-coordinate of $\mathrm{challenge_PK}$.  
- Find $x_m$ such that $| x_m - x_c | \le \delta$ and $(x_m,y_m)$ is a valid secp256k1 point.  
- $\delta$ reflects the ‚Äúdifficulty‚Äù of finding such a key.

### 2.4. Create a Ring Signature

Form a ring of two public keys: $\{P_A, P_{\mathrm{mined}}\}$.  
Use *your real private key* to sign, producing a ring signature that proves **one** of the private keys (either $\mathrm{sk}_A$ or $\mathrm{sk_mined}$) signed‚Äîbut not which one.

### 2.5. Publish the Ghost Event

Publish a standard Nostr event (`kind`, `content`, etc.) plus tags:

- `["ghost", "block-hash", "<H_B>"]`  
- `["ghost", "block-hash-timestamp", "<t_B>"]`  

The event‚Äôs `sig` field is the **ring signature**. Verifiers can:

1. Check validity of the ring signature over $\{P_A, P_{\mathrm{mined}}\}$.  
2. Recompute $\mathrm{challenge_PK}$ from $\langle P_A, H_B\rangle$.  
3. Measure how close $P_{\mathrm{mined}}$ is to $\mathrm{challenge_PK}$ (i.e., proof-of-work difficulty).  
4. Conclude: ‚ÄúEither Alice really signed, or someone else who found a matching $P_{\mathrm{mined}}$ did.‚Äù

---

## 3. Ephemerality & Deniability

- Over time, more keys can be found that also satisfy the distance requirement. This undermines any **unique** link to your real key.  
- The older the referenced block, the more plausible it is that another party found a matching key in that time window.

---

## 4. Client & Relay Behavior

### 4.1. Clients

- Display ‚ÄúDeniable‚Äù or ‚ÄúGhost‚Äù for events with `ghost` tags.  
- Show $\delta$ to indicate how hard it is to find a matching mined key.  
- Emphasize **time**: if the event references an older block, collisions become more likely, thus increasing deniability.

### 4.2. Relays

- Treat Ghost Events like any other events.  
- Optionally index them for specialized queries by `ghost` tags.  
- No special handling is required to maintain the protocol‚Äôs security.

---

## 5. Security Considerations

1. **Ring Signature Robustness**  
   Any weaknesses in the ring signature could leak which key was used.  

2. **Choice of $\delta$**  
   A smaller $\delta$ means harder PoW but stronger initial binding to your identity. A larger $\delta$ lowers the barrier for collisions, boosting deniability sooner.

3. **Block Hash Trust**  
   Must rely on a valid, widely recognized Bitcoin chain tip.  

4. **Long-Term Attacks**  
   As time passes or computational power grows, collisions become easier.  

5. **Anyone Can Forge**  
   Attackers can craft a Ghost Event referencing *your* key without your involvement, ensuring it‚Äôs never definitively tied to you.  

---

## 6. Example Workflow

1. **Alice Picks a Block**  
   She picks a recent (or somewhat older) Bitcoin block $B$.  
2. **Compute Challenge**  
   $S = \mathrm{SHA256}(P_A \| H_B)$, then $\mathrm{challenge_PK} = \mathrm{HashToCurve}(S)$.  
3. **Select Mined Key**  
   Choose $P_{\mathrm{mined}}$ with $| x_m - x_c | \le \delta$. 
   Ideally, clients will offer smart UIs to help pick $\delta$ to match the desired level of deniability.

   We also can combine that  with [NIP-40](https://github.com/nostr-protocol/nips/blob/master/40.md) tags.
4. **Ring Signature**  
   The ring is $\{P_A, P_{\mathrm{mined}}\}$. Alice signs with $\mathrm{sk}_A $.  
5. **Publish**  
   Attach `["ghost", "block-hash", <Block Hash>]` and so forth, and post to relays.  
6. **Verify**  
   Clients confirm ring signature validity and check the PoW distance.

---

## 7. OpenTimestamps (OTS) "Resistance"

Even if the event is OTS-stamped at publication, Ghost Events remain deniable because:

- They can reference arbitrary *older* blocks and with a smaller $\delta$, moving the event‚Äôs creation window further back,
but also making it the total PoW harder.
- Thus, an OTS proof can confirm the event *existed*, but not that *only you* could have created it, as all components 
to forge the event are public and were available since the block was mined.

---

## 8. Example Ghost Event JSON

```json
{
  "id": "eb4cc8b3ff2b6f2c000ad353...",
  "pubkey": "npub1al1c3......",
  "created_at": 1699876543,
  "kind": 1,
  "tags": [
    ["ghost", "block-hash", "00000000000000000004f13f..."],
    ["ghost", "block-hash-timestamp", "1699876000"]
  ],
  "content": "Having a little fun tonight... üçª",
  "sig": "f6c3e7564db51ac8dbe2c790fa12785b036ebc64..."
}
